So What are Trees:-
a Tree is not just a data structure—it is the ultimate manifestation of Recursion.

In Linked Lists, data moves in a straight line (Linear). In Trees, data branches out (Hierarchical). If you understand Recursion (which we just mastered), Trees will be like child's play to you.
1. What is a Tree?

Imagine an upside-down tree. The roots are at the top, and the leaves are at the bottom.

    Node: A container for data (like a box).

    Root: The very top node. Every tree has exactly one root.

    Parent/Child: If Node A points to Node B, A is the parent, and B is the child.

    Leaf: A node that has no children (the end of a branch).

    Subtree: Every child of a node is itself the "root" of a smaller tree. This is why trees are recursive!

    Ancestors: All nodes in the path from the root to that node.

The Binary Tree 

In a Binary Tree, each node can have at most 2 children. We call them the Left Child and the Right Child.
Just like a Linked List has next, a Tree node has left and right.
struct Node {
    int data;
    Node* left;
    Node* right;

    // Constructor to make life easy
    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};
The Four Ways to Traverse a Tree (The "Must-Know")

If I give you a tree, how do you visit every node? There are four legendary ways. You must master the "Order" of visiting: Node (N), Left (L), and Right (R).
I. Pre-order Traversal (N-L-R)

    Visit the Node first.

    Go to the Left subtree.

    Go to the Right subtree. Use case: Used to create a copy of the tree.

II. In-order Traversal (L-N-R)

    Go to the Left subtree.

    Visit the Node.

    Go to the Right subtree. Use case: In a Binary Search Tree (BST), this gives you the data in sorted order!

III. Post-order Traversal (L-R-N)

    Go to the Left subtree.

    Go to the Right subtree.

    Visit the Node. Use case: Used to delete the tree (you delete children before the parent).

IV. Level-order Traversal (Breadth-First Search)

Visit nodes level by level (top to bottom, left to right). We use a Queue for this.

void inOrder(Node* root) {
    // BASE CASE: If the tree is empty, return
    if (root == nullptr) return;

    inOrder(root->left);       // L: Visit Left
    cout << root->data << " "; // N: Visit Node
    inOrder(root->right);      // R: Visit Right
}
Why are Trees so Important?

    Search Efficiency: In a balanced tree, you can find any item in O(logN) time. (Fast!)

    Organization: Your computer’s file system (Folders inside Folders) is a Tree.

    HTML DOM: Web pages are structured as trees.

/*
============================================================================
TREES MASTER GUIDE — THE RECURSIVE HIERARCHY
============================================================================

[1] THE RECURSIVE DEFINITION
----------------------------
A Tree is either:
1. Empty (NULL).
2. A Root node containing a Left Subtree and a Right Subtree.

[2] THE BIG THREE TRAVERSALS
----------------------------
• PRE-ORDER  (Root, Left, Right) -> "Check self, then children."
• IN-ORDER   (Left, Root, Right) -> "Left to Right" (Sorted in BST).
• POST-ORDER (Left, Right, Root) -> "Children first, then self."

[3] DEPTH vs. HEIGHT
--------------------
• DEPTH:  How many edges from the ROOT to the node.
• HEIGHT: How many edges from the node to the deepest LEAF.

[4] WHY RECURSION WORKS
-----------------------
Every time we move to 'root->left', we are treating that child 
as the "New Root" of its own smaller tree. 
============================================================================
*/


Metric,Formula,Explanation
Max Nodes at Level i,2i,Level 0 (Root) has 20=1 node. Level 2 has 22=4 nodes.
Max Nodes in Height H,2H−1,"A ""Perfect"" tree of height 3 has 23−1=7 nodes."
Min Height with N nodes,log2​(N+1),"This happens in a ""Balanced"" tree (the most efficient)."
Max Height with N nodes,N,"This happens in a ""Skewed"" tree (looks like a Linked List)."
Leaf Nodes Relationship,L=I+1,"In a full binary tree, the number of leaves (L) is always 1 more than internal nodes (I)."

1. The Types of Binary Trees (The Elite Encyclopedia)
I. Full Binary Tree (or Strict Binary Tree)

    Rule: Every node has either 0 or 2 children.

    The Logic: No node ever has only one child. It's either a leaf or a parent of two.

    Formula: If L is the number of leaves and I is internal nodes, then L=I+1.

II. Perfect Binary Tree

    Rule: All internal nodes have 2 children, and all leaves are at the same level.

    The Logic: It is a perfect triangle. There is no "gap" anywhere.

    Formula: Total nodes N=2h+1−1 (where h is edge-based height).

III. Complete Binary Tree

    Rule: All levels are completely filled except possibly the last level, and the last level has all nodes as far left as possible.

    The Logic: This is the structure used for Heaps. You fill it like you're reading a book: left to right, row by row.

IV. Balanced Binary Tree

    Rule: For every single node, the height of the left and right subtrees differs by at most 1.

    The Logic: It keeps the tree "short" so searching is fast (O(logN)).

    Formula: ∣height(left)−height(right)∣≤1.

V. Degenerate (or Skewed) Tree

    Rule: Every node has only one child.

    The Logic: It’s basically a Linked List in disguise.

    Performance: This is the "Worst Case" where search becomes O(N).

2. The "Elite" Mathematical Vault (Related Formulas)

To be the best, you need the math that others forget. Save these for your documentation:
Tree Type	Property / Formula	Why it matters
Any Binary Tree	Max nodes at level L=2L	Helps calculate memory allocation.
Perfect Tree	N=2H+1−1	Tells you the exact capacity of the tree.
Complete Tree	Height H=⌊log2​N⌋	Guarantees O(logN) performance.
Full Tree	Number of Leaves = Internal Nodes + 1	Used in structural proofs.


The Binary Search Tree (BST) – The "Ordered" King
In a regular Binary Tree, data can be anywhere. In a BST, there is a strict law:

    Left Rule: Every node in the left subtree must be smaller than the parent.

    Right Rule: Every node in the right subtree must be bigger than the parent.

Why is this legendary?

Because it allows you to search for a value by cutting the search area in half every time. It turns an O(N) search into an O(logN) search.
2. Level Order Traversal (The BFS Way)

Earlier, we talked about Pre-order, In-order, and Post-order. Those are Depth First Search (DFS)—they go deep before they go wide. Level Order Traversal is Breadth First Search (BFS)—it visits every node on Level 0, then Level 1, then Level 2.
Master's Formula Section: BST Edition

To be the best, you need to know the properties of a BST like the back of your hand:
Property	Formula / Fact
In-order Traversal	Always results in a Sorted Array.
Search Time (Balanced)	O(log2​N)
Search Time (Skewed)	O(N) (The "Degenerate" nightmare).
Successor/Predecessor	Finding the next larger or smaller element.
Note:
In Binary Search Tree there are two types of traversal we can do:
The first is the bfs so we do level order traversal here.
The second one is dfs and here we do threee traversal that is:-inorder,postorder,preorder 

so we can do any one in the bst so remember that.

Operation	Best/Average Case (Balanced)	Worst Case (Skewed)
Search	O(log2​N)	O(N)
Insert	O(log2​N)	O(N)
Delete	O(log2​N)	O(N)
/*
============================================================================
BINARY SEARCH TREE (BST) — SEARCH & INSERT MASTER GUIDE
============================================================================

[1] THE BST INVARIANT
---------------------
• Left Child < Root < Right Child.
• This rule must be true for EVERY node in the tree.

[2] SEARCHING LOGIC
-------------------
• It is a "Path" search. You never branch into two directions.
• You either go Left, go Right, or Stop.
• This is why the time complexity is O(Height).

[3] INSERTION LOGIC
-------------------
• We never "re-arrange" the tree during a simple insertion.
• We find the first available NULL spot that satisfies the BST rule.
• The new node always becomes a LEAF.

[4] THE "SKEWED" DANGER
-----------------------
• If you insert numbers in sorted order (1, 2, 3, 4...), the BST 
  becomes a "Degenerate Tree" (Linked List).
• Search time drops from O(log N) to O(N).
• This is why "Balanced" trees like AVL or Red-Black are needed later.
============================================================================
*/
